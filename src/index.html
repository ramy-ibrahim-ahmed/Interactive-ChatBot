<!DOCTYPE html>
<html lang="ar" dir="ltr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brhuma</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }

        /* Custom Scrollbar */
        #chat-container::-webkit-scrollbar {
            width: 8px;
        }

        #chat-container::-webkit-scrollbar-track {
            background: #f1f5f9;
        }

        #chat-container::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 4px;
        }

        #chat-container::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }

        /* Chat Bubbles */
        .chat-bubble-user {
            background-color: #3b82f6;
            color: white;
        }

        /* --- ENHANCEMENT 1: Grid Background --- */
        #chat-container {
            background-color: #f8fafc;
            /* slate-50 */
            background-image:
                linear-gradient(to right, #e2e8f0 1px, transparent 1px),
                linear-gradient(to bottom, #e2e8f0 1px, transparent 1px);
            background-size: 6rem 3rem;
            /* Increased to 64px grid for wider appearance */
        }

        /* Persona idle animation */
        @keyframes bob {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-5px);
            }
        }

        #persona-svg {
            animation: bob 4s ease-in-out infinite;
        }

        /* Blinking Cursor for typing indicator */
        @keyframes blink {
            50% {
                opacity: 0;
            }
        }

        .blinking-cursor {
            display: inline-block;
            width: 8px;
            height: 1.2em;
            background-color: #333;
            animation: blink 1s step-end infinite;
            vertical-align: text-bottom;
        }

        /* --- ENHANCEMENT 2: Mic Button Recording Animation --- */
        @keyframes pulse-shadow {
            0% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(239, 68, 68, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
            }
        }

        .recording-pulse {
            animation: pulse-shadow 2s infinite;
        }
    </style>
</head>

<body class="bg-slate-100 h-screen w-screen overflow-hidden">

    <svg style="position: absolute; width: 0; height: 0;" aria-hidden="true">
        <filter id="sketchy">
            <feTurbulence type="fractalNoise" baseFrequency="0.05" numOctaves="3" result="noise" />
            <feDisplacementMap in="SourceGraphic" in2="noise" scale="2" xChannelSelector="R" yChannelSelector="G" />
        </filter>
    </svg>

    <div dir="ltr" class="bg-white w-full h-full flex flex-col md:flex-row overflow-hidden">

        <div
            class="w-full md:w-1/3 bg-slate-800 flex flex-col items-center justify-center p-8 border-b-4 border-slate-700 md:border-r-4 md:border-b-0">
            <div class="w-48 h-48 md:w-64 md:h-64">
                <svg id="persona-svg" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
                    <path id="head" fill="#475569"
                        d="M 50,25 C 25,25 25,50 25,75 L 25,125 C 25,150 25,175 50,175 L 150,175 C 175,175 175,150 175,125 L 175,75 C 175,50 175,25 150,25 Z" />

                    <rect x="55" y="60" width="90" height="40" rx="20" fill="#1e293b" />

                    <g id="eyes">
                        <circle id="left-eye" cx="80" cy="80" r="8" fill="#34d399" />
                        <circle id="right-eye" cx="120" cy="80" r="8" fill="#34d399" />
                    </g>

                    <g id="mouth">
                        <path d="M 80 125 Q 100 140 120 125" stroke="#34d399" stroke-width="4" fill="none"
                            stroke-linecap="round" />
                    </g>
                </svg>
            </div>
            <div class="text-center mt-4">
                <h2 id="persona-name" class="text-2xl font-bold text-white">Ø¨Ø±Ù‡ÙˆÙ…Ø§</h2>
                <p id="persona-status" class="text-emerald-400 font-medium">Ù…ØªØµÙ„</p>
            </div>
        </div>

        <div class="w-full md:w-2/3 flex flex-col h-full">
            <div class="flex-1 p-6 overflow-y-auto space-y-4" id="chat-container">
            </div>
            <div class="p-4 bg-white border-t border-slate-200">
                <form id="chat-form" class="flex items-end space-x-3">
                    <textarea id="chat-input" rows="3" placeholder="Ø§ÙƒØªØ¨ Ø³Ø¤Ø§Ù„Ùƒ Ù‡Ù†Ø§..."
                        class="flex-1 p-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none transition resize-none text-right bg-white"
                        dir="rtl" autocomplete="off"></textarea>

                    <button type="button" id="mic-button"
                        class="bg-transparent border-2 border-green-500 hover:bg-green-100 hover:border-green-700 hover:text-green-700 text-green-500 font-bold p-3 rounded-full shadow-lg transition-all duration-200 ease-in-out active:scale-95 flex items-center justify-center w-12 h-12"
                        style="filter: url(#sketchy);">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"></path>
                            <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                            <line x1="12" x2="12" y1="19" y2="22"></line>
                        </svg>
                    </button>

                    <button type="submit" id="send-button"
                        class="bg-transparent border-2 border-blue-500 hover:bg-blue-100 hover:border-blue-700 hover:text-blue-700 text-blue-500 font-bold p-3 rounded-lg transition-transform duration-200 ease-in-out active:scale-95 flex items-center justify-center w-12 h-12"
                        style="filter: url(#sketchy);">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                            class="feather feather-send">
                            <line x1="22" y1="2" x2="11" y2="13"></line>
                            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                        </svg>
                    </button>
                </form>
            </div>
        </div>
    </div>

    <script>
        // DOM Elements (no changes here)
        const chatContainer = document.getElementById('chat-container');
        const chatForm = document.getElementById('chat-form');
        const chatInput = document.getElementById('chat-input');
        const personaStatus = document.getElementById('persona-status');
        const eyes = document.getElementById('eyes');
        const mouth = document.getElementById('mouth');
        const sendButton = document.getElementById('send-button');
        const micButton = document.getElementById('mic-button');

        // Chat state & other variables (no changes here)
        let isLoading = false;
        let isRecording = false;
        let mediaRecorder;
        let audioChunks = [];
        let lastUserMessage;
        let isAudioInput = false;
        const backendUrl = '/api/v1/chat';
        const ttsUrl = '/api/v1/chat/tts';

        // Helper functions and persona states
        function isRTL(text) {
            const rtlChars = /[\u0590-\u05FF\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;
            return rtlChars.test(text);
        }
        let blinkInterval;
        const personaStates = {
            idle: {
                mouth: '<path d="M 80 125 Q 100 140 120 125" stroke="#34d399" stroke-width="4" fill="none" stroke-linecap="round" />',
                eyesOpen: '<circle id="left-eye" cx="80" cy="80" r="8" fill="#34d399" /><circle id="right-eye" cx="120" cy="80" r="8" fill="#34d399" />',
                eyesClosed: '<path d="M 70 80 H 90" stroke="#34d399" stroke-width="4" fill="none" stroke-linecap="round" /><path d="M 110 80 H 130" stroke="#34d399" stroke-width="4" fill="none" stroke-linecap="round" />',
                status: 'Ù…ØªØµÙ„',
                statusColor: 'text-emerald-400'
            },
            thinking: {
                mouth: '<path d="M 80 130 H 120" stroke="#f59e0b" stroke-width="4" fill="none" stroke-linecap="round" />',
                eyes: '<circle id="left-eye" cx="80" cy="75" r="8" fill="#f59e0b" /><circle id="right-eye" cx="120" cy="75" r="8" fill="#f59e0b" />',
                // --- ENHANCEMENT 3: Updated fallback thinking status ---
                status: 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©...',
                statusColor: 'text-amber-400'
            },
            talking: {
                mouth: [
                    '<path d="M 80 125 Q 100 130 120 125" stroke="#60a5fa" stroke-width="4" fill="none" stroke-linecap="round" />',
                    '<path d="M 80 125 Q 100 135 120 125" stroke="#60a5fa" stroke-width="4" fill="none" stroke-linecap="round" />',
                    '<path d="M 80 125 Q 100 140 120 125" stroke="#60a5fa" stroke-width="4" fill="none" stroke-linecap="round" />'
                ],
                eyes: '<circle id="left-eye" cx="80" cy="80" r="9" fill="#60a5fa" /><circle id="right-eye" cx="120" cy="80" r="9" fill="#60a5fa" />',
                status: 'ÙŠØ±Ø¯...',
                statusColor: 'text-blue-400'
            },
            error: {
                mouth: '<path d="M 80 135 Q 100 120 120 135" stroke="#f43f5e" stroke-width="4" fill="none" stroke-linecap="round" />',
                eyes: '<path d="M 72 72 L 88 88 M 88 72 L 72 88" stroke="#f43f5e" stroke-width="4" fill="none" stroke-linecap="round" /><path d="M 112 72 L 128 88 M 128 72 L 112 88" stroke="#f43f5e" stroke-width="4" fill="none" stroke-linecap="round" />',
                status: 'Ø®Ø·Ø£',
                statusColor: 'text-red-500'
            }
        };
        let talkInterval;
        function setPersonaState(state) {
            clearInterval(blinkInterval);
            clearInterval(talkInterval);
            const s = personaStates[state];

            personaStatus.textContent = s.status;
            personaStatus.className = `font-medium ${s.statusColor}`;

            switch (state) {
                case 'idle':
                    mouth.innerHTML = s.mouth;
                    eyes.innerHTML = s.eyesOpen;
                    blinkInterval = setInterval(() => {
                        eyes.innerHTML = s.eyesClosed;
                        setTimeout(() => {
                            if (personaStatus.textContent === 'Ù…ØªØµÙ„') {
                                eyes.innerHTML = s.eyesOpen;
                            }
                        }, 200);
                    }, 4000);
                    break;
                case 'thinking':
                    mouth.innerHTML = s.mouth;
                    eyes.innerHTML = s.eyes;
                    break;
                case 'talking':
                    eyes.innerHTML = s.eyes;
                    let mouthIndex = 0;
                    talkInterval = setInterval(() => {
                        mouth.innerHTML = s.mouth[mouthIndex];
                        mouthIndex = (mouthIndex + 1) % s.mouth.length;
                    }, 150);
                    break;
                case 'error':
                    mouth.innerHTML = s.mouth;
                    eyes.innerHTML = s.eyes;
                    break;
            }
        }

        function addAudioButton(messageElement) {
            const audioButton = document.createElement('button');
            audioButton.classList.add('mt-2', 'flex', 'items-center', 'gap-1', 'text-blue-500', 'bg-transparent', 'border-2', 'border-blue-500', 'hover:bg-blue-100', 'hover:border-blue-600', 'hover:text-blue-600', 'px-3', 'py-1', 'rounded-lg', 'transition-colors', 'font-medium', 'text-sm');
            audioButton.style.filter = 'url(#sketchy)';
            audioButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                    <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                </svg>
                Ø§Ø³ØªÙ…Ø¹ Ø¥Ù„Ù‰ Ø§Ù„Ø±Ø¯
            `;
            audioButton.onclick = async () => {
                const text = messageElement.dataset.originalText;
                if (!text) return;
                try {
                    audioButton.disabled = true;
                    audioButton.innerHTML = `<span class="animate-pulse">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙˆÙ„ÙŠØ¯...</span>`;
                    const formData = new FormData();
                    formData.append('text', text);
                    const res = await fetch(ttsUrl, { method: 'POST', body: formData });
                    if (!res.ok) throw new Error('TTS failed');
                    const data = await res.json();
                    const audio = new Audio(data.audio_path);
                    audio.play().catch(e => console.error('Playback error:', e));
                    audio.onplaying = () => setPersonaState('talking');
                    audio.onended = () => {
                        setPersonaState('idle');
                        resetButton();
                    };
                    audio.onerror = () => resetButton();
                    function resetButton() {
                        audioButton.disabled = false;
                        audioButton.innerHTML = `
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                                <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                            </svg>
                            Ø§Ø³ØªÙ…Ø¹ Ø¥Ù„Ù‰ Ø§Ù„Ø±Ø¯
                        `;
                    }
                } catch (e) {
                    console.error('TTS error:', e);
                    alert('ÙØ´Ù„ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª.');
                    audioButton.disabled = false;
                    audioButton.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                            <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                        </svg>
                        Ø§Ø³ØªÙ…Ø¹ Ø¥Ù„Ù‰ Ø§Ù„Ø±Ø¯
                    `;
                }
            };
            messageElement.appendChild(audioButton);
        }

        function addMessageToChat(sender, message, returnElement = false) {
            const messageWrapper = document.createElement('div');
            messageWrapper.classList.add('mb-4', 'w-full', 'animate__animated', 'animate__fadeIn');
            messageWrapper.classList.add('flex', sender === 'user' ? 'justify-end' : 'justify-start');

            const messageElement = document.createElement('div');
            messageElement.classList.add('px-4', 'py-3', 'break-words', 'rounded-lg', 'shadow-md', 'max-w-xs', 'lg:max-w-md');

            if (sender === 'bot') {
                messageElement.dataset.originalText = message;
                if (message === '...') {
                    messageElement.innerHTML = '<span class="blinking-cursor"></span>';
                } else {
                    messageElement.innerHTML = marked.parse(message);
                    addAudioButton(messageElement);
                }
                messageElement.classList.add('bg-slate-200', 'text-slate-800');
            } else {
                messageElement.textContent = message;
                messageElement.classList.add('chat-bubble-user');
            }

            if (isRTL(messageElement.textContent.trim())) {
                messageElement.dir = 'rtl';
                messageElement.classList.add('text-right');
            } else {
                messageElement.dir = 'ltr';
                messageElement.classList.add('text-left');
            }

            messageWrapper.appendChild(messageElement);
            chatContainer.appendChild(messageWrapper);
            chatContainer.scrollTop = chatContainer.scrollHeight;

            if (returnElement) {
                return messageElement;
            }

            if (sender === 'user') {
                lastUserMessage = messageElement;
            }
        }

        function updateLastUserMessage(text) {
            if (lastUserMessage) {
                lastUserMessage.textContent = text;
                if (isRTL(text)) {
                    lastUserMessage.dir = 'rtl';
                    lastUserMessage.classList.remove('text-left');
                    lastUserMessage.classList.add('text-right');
                } else {
                    lastUserMessage.dir = 'ltr';
                    lastUserMessage.classList.remove('text-right');
                    lastUserMessage.classList.add('text-left');
                }
            }
        };

        // --- ENHANCEMENT 3: Rewritten to update persona status directly ---
        function handleStreamEvent(data, botMessageElement) {
            const event = data.event;

            if (event === 'start_node') {
                setPersonaState('thinking'); // Sets the thinking face, color, and fallback text
                const node = data.node;
                let statusText;

                switch (node) {
                    case 'classify_intent': statusText = 'ÙÙ‡Ù… Ø§Ù„Ø·Ù„Ø¨... ğŸ¤”'; break;
                    case 'query_write': statusText = 'ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø§Ø³ØªÙØ³Ø§Ø±... âœï¸'; break;
                    case 'system_recognize': statusText = 'ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù†Ø¸Ø§Ù…... ğŸ•µï¸'; break;
                    case 'search': statusText = 'Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ù…Ø¹Ø±ÙØ©... ğŸ”'; break;
                    case 'formate_search': statusText = 'ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù†ØªØ§Ø¦Ø¬... ğŸ“‹'; break;
                    case 'analysis': statusText = 'ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬... ğŸ“Š'; break;
                    case 'chat': statusText = 'ØªØ¬Ù‡ÙŠØ² Ø§Ù„Ø±Ø¯... ğŸ’¬'; break;
                    case 'tts': statusText = 'ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØª... ğŸ”Š'; break;
                    default: statusText = 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©...'; break;
                }

                // Directly update the persona status text, overriding the default from setPersonaState
                personaStatus.textContent = statusText;

            } else if (event === 'final_answer') {
                const finalData = data.data;
                if (isAudioInput && finalData.user_message) {
                    updateLastUserMessage(finalData.user_message);
                }
                botMessageElement.dataset.originalText = finalData.answer || "Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† Ø¥ÙŠØ¬Ø§Ø¯ Ø¥Ø¬Ø§Ø¨Ø©.";
                botMessageElement.innerHTML = marked.parse(finalData.answer || "Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† Ø¥ÙŠØ¬Ø§Ø¯ Ø¥Ø¬Ø§Ø¨Ø©.");
                addAudioButton(botMessageElement);

                const audioUrl = finalData.audio_path;
                if (audioUrl) {
                    const audio = new Audio(audioUrl);
                    audio.play().catch(e => console.error('Audio playback error:', e));
                    audio.onplaying = () => setPersonaState('talking');
                    audio.onended = () => setPersonaState('idle');
                } else {
                    setPersonaState('idle');
                }
            } else if (event === 'error') {
                botMessageElement.innerHTML = marked.parse(`Ø­Ø¯Ø« Ø®Ø·Ø£: ${data.message}`);
                setPersonaState('error');
                setTimeout(() => setPersonaState('idle'), 4000);
            }
        }

        async function callChatbotAPI(prompt = null, audioBlob = null) {
            isLoading = true;
            setPersonaState('thinking');
            sendButton.disabled = true;
            chatInput.disabled = true;
            micButton.disabled = true;

            const botMessageElement = addMessageToChat('bot', '...', true);

            try {
                const formData = new FormData();
                if (audioBlob) {
                    formData.append('audio', audioBlob, 'recording.webm');
                } else if (prompt) {
                    formData.append('query', prompt);
                }

                const response = await fetch(backendUrl, { method: 'POST', body: formData });

                if (!response.ok) throw new Error(`API error: ${response.status} ${response.statusText}`);

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const parts = buffer.split('\n\n');
                    buffer = parts.pop(); // Last part might be incomplete

                    for (const part of parts) {
                        if (part.startsWith('data: ')) {
                            const jsonString = part.substring(6);
                            if (jsonString) {
                                try {
                                    const data = JSON.parse(jsonString);
                                    handleStreamEvent(data, botMessageElement);
                                } catch (e) {
                                    console.error('Error parsing streaming JSON:', e, `Received: "${jsonString}"`);
                                }
                            }
                        }
                    }
                }
            } catch (error) {
                console.error("Chatbot API Error:", error);
                botMessageElement.innerHTML = marked.parse('Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø«Øª Ù…Ø´ÙƒÙ„Ø©. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.');
                setPersonaState('error');
                setTimeout(() => setPersonaState('idle'), 4000);
            } finally {
                isLoading = false;
                sendButton.disabled = false;
                chatInput.disabled = false;
                micButton.disabled = false;
                isAudioInput = false;
                chatInput.focus();
            }
        }

        // Text input submit
        chatForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const userInput = chatInput.value.trim();
            if (userInput && !isLoading) {
                addMessageToChat('user', userInput);
                chatInput.value = '';
                callChatbotAPI(userInput);
            }
        });

        // Audio input
        micButton.addEventListener('click', async () => {
            if (isLoading) return;

            if (!isRecording) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    mediaRecorder.ondataavailable = (e) => audioChunks.push(e.data);
                    mediaRecorder.onstop = () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        addMessageToChat('user', 'Ø±Ø³Ø§Ù„Ø© ØµÙˆØªÙŠØ©...');
                        isAudioInput = true;
                        callChatbotAPI(null, audioBlob);
                    };
                    mediaRecorder.start();
                    isRecording = true;
                    micButton.classList.remove('border-green-500', 'text-green-500', 'hover:bg-green-100', 'hover:border-green-700', 'hover:text-green-700');
                    micButton.classList.add('border-red-500', 'text-red-500', 'hover:bg-red-100', 'hover:border-red-700', 'hover:text-red-700', 'recording-pulse');
                } catch (error) {
                    console.error('Microphone access error:', error);
                    alert('ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ†.');
                }
            } else {
                mediaRecorder.stop();
                isRecording = false;
                micButton.classList.remove('border-red-500', 'text-red-500', 'hover:bg-red-100', 'hover:border-red-700', 'hover:text-red-700', 'recording-pulse');
                micButton.classList.add('border-green-500', 'text-green-500', 'hover:bg-green-100', 'hover:border-green-700', 'hover:text-green-700');
            }
        });

        // Initial welcome message
        window.addEventListener('load', () => {
            setPersonaState('idle');
            setTimeout(() => {
                addMessageToChat('bot', "Ù…Ø±Ø­Ø¨Ø§! Ø£Ù†Ø§ Ø¨Ø±Ù‡ÙˆÙ…Ø§ØŒ Ø¬Ø§Ù‡Ø² Ù„Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¹Ù„Ù‰ Ø£Ø³Ø¦Ù„ØªÙƒ. Ù…Ø§ Ù‡Ùˆ Ø³Ø¤Ø§Ù„ÙƒØŸ");
            }, 500);
        });

    </script>
</body>

</html>